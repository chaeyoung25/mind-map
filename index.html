<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Mind Map (v6.0 Perfect Selection)</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <style>
        /* --- Mac Style Pastel Theme --- */
        :root {
            --bg-color: #F5F5F7;
            --panel-bg: rgba(255, 255, 255, 0.98);
            --text-color: #1D1D1F;
            --border-color: rgba(0, 0, 0, 0.1);
            --accent-color: #007AFF;
            --danger-color: #FF3B30;
            --selection-blue: rgba(0, 122, 255, 0.2);
            --selection-border: #007AFF;
        }
        [data-theme="dark"] {
            --bg-color: #191919;
            --panel-bg: rgba(40, 40, 40, 0.95);
            --text-color: #F5F5F7;
            --border-color: rgba(255, 255, 255, 0.15);
            --accent-color: #0A84FF;
        }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Pretendard", sans-serif; 
            padding: 20px; background-color: var(--bg-color); color: var(--text-color); margin: 0; height: 100vh; 
            box-sizing: border-box; transition: background-color 0.3s ease; backdrop-filter: blur(20px);
            overflow: hidden; user-select: none; 
        }
        .container { display: flex; gap: 20px; height: 92vh; flex-direction: column; }
        @media (min-width: 900px) { 
            .container { flex-direction: row; } 
            .input-panel { width: 340px; flex-shrink: 0; } 
            .map-panel { flex-grow: 1; } 
        }
        .panel { 
            background: var(--panel-bg); padding: 20px; border-radius: 12px; 
            box-shadow: 0 4px 24px rgba(0,0,0,0.08); border: 1px solid var(--border-color); 
            display: flex; flex-direction: column; position: relative; 
            backdrop-filter: blur(20px);
        }
        h2 { margin: 0 0 15px 0; font-size: 1.1rem; font-weight: 600; display: flex; justify-content: space-between; align-items: center; }
        textarea { 
            width: 100%; height: 200px; padding: 14px; border-radius: 10px; border: 1px solid var(--border-color); 
            resize: none; font-family: inherit; margin-bottom: 10px; background: var(--bg-color); 
            color: var(--text-color); box-sizing: border-box; outline: none; transition: 0.2s; font-size: 0.9rem; line-height: 1.5;
            user-select: text; 
        }
        textarea:focus { border-color: var(--accent-color); }
        .btn { padding: 12px; border-radius: 10px; border: none; cursor: pointer; font-weight: 600; font-size: 0.9rem; transition: all 0.2s; }
        .btn-primary { background-color: var(--accent-color); color: white; width: 100%; margin-top: 10px; box-shadow: 0 2px 8px rgba(0,122,255,0.25); }
        .btn-primary:hover { transform: translateY(-1px); opacity: 0.9; }
        .btn-secondary { background-color: rgba(120, 120, 128, 0.1); color: var(--text-color); font-size: 0.8rem; }
        .btn-secondary:hover { background-color: rgba(120, 120, 128, 0.2); }
        .btn-toolbar { display: flex; gap: 6px; margin-bottom: 15px; }
        .btn-toolbar .btn { flex: 1; }
        #mynetwork { width: 100%; height: 100%; outline: none; cursor: default; }
        
        /* Selection Box - Correctly Positioned */
        #selectionBox {
            position: absolute;
            background-color: var(--selection-blue);
            border: 1px solid var(--selection-border);
            display: none;
            z-index: 9999;
            pointer-events: none;
        }
        .map-controls { 
            position: absolute; top: 16px; right: 16px; left: 16px; 
            display: flex; justify-content: space-between; pointer-events: none; z-index: 10;
        }
        .control-group { 
            pointer-events: auto; display: flex; gap: 5px; background: var(--panel-bg); 
            padding: 5px; border-radius: 10px; border: 1px solid var(--border-color); 
            box-shadow: 0 4px 15px rgba(0,0,0,0.05); flex-wrap: wrap; align-items: center;
        }
        .control-group button { 
            padding: 6px 10px; font-size: 0.75rem; background: transparent; border: none; 
            border-radius: 6px; cursor: pointer; color: var(--text-color); transition: 0.2s; 
            display: flex; align-items: center; gap: 4px; font-weight: 500;
        }
        .control-group button:hover { background-color: rgba(0,0,0,0.05); }
        .btn-add { color: var(--accent-color) !important; }
        .btn-unlink { color: var(--text-color) !important; opacity: 0.8; }
        .btn-delete { color: var(--danger-color) !important; }
        #statusMessage {
            position: absolute; top: 70px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.75); color: white; padding: 8px 20px; border-radius: 30px;
            font-size: 0.85rem; font-weight: 500; box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 100; backdrop-filter: blur(10px);
        }
        .version-tag { font-size: 0.7rem; color: var(--text-color); opacity: 0.4; margin-top: 15px; text-align: right; }
        #contextToolbar, #edgeToolbar { display: none; }
    </style>
</head>
<body>

    <div id="selectionBox"></div>

    <div class="container">
        <div class="input-panel panel">
            <h2>
                Settings
                <button onclick="toggleTheme()" style="background:none; border:none; cursor:pointer; font-size:1.4rem; opacity:0.8;" title="Toggle Dark Mode">üåì</button>
            </h2>
            
            <div class="btn-toolbar">
                <button class="btn btn-secondary" onclick="exportProject()">üíæ Save</button>
                <button class="btn btn-secondary" onclick="document.getElementById('fileLoader').click()">üìÇ Load</button>
                <input type="file" id="fileLoader" style="display:none" onchange="importProject(event)" accept=".json">
            </div>
            
            <button class="btn btn-secondary" onclick="createNewProject()" style="width:100%; margin-bottom:15px; border:1px dashed var(--accent-color); color:var(--accent-color);">‚ú® New Project</button>

            <label style="font-size:0.85rem; font-weight:600; color:var(--text-color); margin-bottom:6px; display:block;">Input Text:</label>
            <textarea id="inputText" placeholder="Paste your text here..."></textarea>
            
            <button class="btn btn-primary" onclick="processData()">‚ú® Generate Mind Map</button>

            <div style="margin-top:auto;">
                <p style="font-size:0.75rem; opacity:0.6; line-height:1.5; margin-bottom:0;">
                    * <b>Multi-Select:</b> Ctrl + Drag Fixed.<br>
                    * <b>System:</b> Rebuilds on layout switch.<br>
                    * <b>Board:</b> Drag & Drop + No lines.
                </p>
                <div class="version-tag">Version 6.0 (Selection Fixed)</div>
            </div>
        </div>

        <div class="map-panel panel" id="mapPanel">
            <div id="statusMessage">Ready</div>

            <div class="map-controls">
                <div style="display:flex; gap:10px;">
                    <div id="contextToolbar" class="control-group" style="border-color: var(--accent-color);">
                        <button class="btn-add" onclick="addChildNode()">‚ûï Add</button>
                        <button onclick="cutSelected()">‚úÇÔ∏è Cut</button>
                        <button onclick="duplicateSelected()">üìÑ Copy</button>
                        <button onclick="pasteNodes()">üìã Paste</button>
                        <button onclick="editNodeText()">‚úèÔ∏è Edit</button>
                        <button onclick="startConnect()">üîó Link</button>
                        <button class="btn-unlink" onclick="unlinkNode()">üîóüíî Unlink</button>
                        <button class="btn-delete" onclick="deleteSelected()">üóë Del</button>
                    </div>
                    <div id="edgeToolbar" class="control-group" style="border-color: var(--warning-color);">
                        <button class="btn-delete" onclick="deleteSelectedEdge()">‚ùå Delete Line</button>
                    </div>
                </div>

                <div class="control-group">
                    <button onclick="undo()" title="Undo">‚Ü©Ô∏è</button>
                    <button onclick="resetMap()" style="color:var(--danger-color)" title="Reset">üîÑ</button>
                    <span style="width:1px; height:15px; background:var(--border-color); margin:0 2px;"></span>
                    <button onclick="switchLayout('UD')">üå≥ Tree</button>
                    <button onclick="switchLayout('LR')">üß± Block</button>
                    <button onclick="switchLayout('Free')">‚ú® Free</button>
                    <button onclick="switchLayout('Board')" title="OneNote Style">üìã Board</button>
                    <span style="width:1px; height:15px; background:var(--border-color); margin:0 2px;"></span>
                    <button onclick="exportMap('png')">üì∑</button>
                    <button onclick="exportWord()">üìù</button>
                </div>
            </div>

            <div id="mynetwork"></div>
        </div>
    </div>

    <script>
        // --- Global State ---
        let network = null;
        let nodesDS = new vis.DataSet([]);
        let edgesDS = new vis.DataSet([]);
        let currentLayout = 'Board'; 
        
        let isDarkMode = false;
        let currentAction = null;
        let actionSourceId = null; 
        
        let historyStack = [];
        let initialState = null;
        const MAX_HISTORY = 50;
        let clipboard = [];

        // Configs
        const BOARD_CONFIG = { colWidth: 320, cardGap: 70, headerY: -300, indent: 25 };
        const LEVEL_COLORS = [
            { bg: '#FFD1DC', border: '#FFB7C5' }, { bg: '#FFE6A7', border: '#FFD580' }, 
            { bg: '#CDF0EA', border: '#A6E3D9' }, { bg: '#E2F0CB', border: '#C7E59B' }, 
            { bg: '#D4E6F1', border: '#AED6F1' }, { bg: '#E8DAEF', border: '#D2B4DE' }, 
            { bg: '#FFFFFF', border: '#E0E0E0' } 
        ];
        function getNodeColor(level) { const idx = Math.min(level, LEVEL_COLORS.length - 1); return LEVEL_COLORS[idx]; }

        // --- Init ---
        window.onload = function() {
            if(localStorage.getItem('theme') === 'dark') toggleTheme();
            if(localStorage.getItem('mindMapSessionV6_0')) {
                restoreSession();
            } else {
                initNetwork([{id:1, label:'Main Topic', level:0, color:{background:'#FFD1DC'}}], [], 'Board');
            }
            setupKeyboardShortcuts();
            setupBoxSelection();
        };

        // --- THE "REBUILD" SWITCH LAYOUT ---
        function switchLayout(type) {
            saveHistory();
            currentLayout = type;
            
            const currentNodes = nodesDS.get();
            const currentEdges = edgesDS.get();

            let newNodes = [];
            let newEdges = [];

            if (type === 'Board') {
                newNodes = calculateBoardPositions(currentNodes, currentEdges);
                newEdges = currentEdges.map(e => ({...e, hidden: true})); // Hide lines for Board
            } else {
                // Clear positions for Tree/Block/Free so engine takes over
                newNodes = currentNodes.map(n => ({
                    ...n,
                    x: undefined,
                    y: undefined,
                    fixed: false 
                }));
                newEdges = currentEdges.map(e => ({...e, hidden: false})); // Show lines
            }

            initNetwork(newNodes, newEdges, type);
            showStatus(type + " Layout Applied");
        }

        // --- Network Initialization ---
        function initNetwork(nodes, edges, layoutType) {
            const container = document.getElementById('mynetwork');
            if (network !== null) { network.destroy(); network = null; }

            nodesDS.clear(); edgesDS.clear();
            nodesDS.add(nodes); edgesDS.add(edges);
            
            currentLayout = layoutType;

            const data = { nodes: nodesDS, edges: edgesDS };
            let options = {
                nodes: { shape: 'box', margin: 10, borderWidth: 1, shadow: true, font: { face: 'Pretendard', color:'#333' } },
                edges: { color: '#B0B0B0', width: 2, smooth: { type: 'cubicBezier', forceDirection: 'vertical', roundness: 0.4 } },
                interaction: { hover: true, selectConnectedEdges: false, multiselect: true, dragView: true },
                physics: false 
            };

            if (layoutType === 'UD') { // Tree
                options.layout = { hierarchical: { enabled: true, direction: "UD", levelSeparation: 200, nodeSpacing: 200, sortMethod: 'hubsize', shakeTowards: 'leaves' } };
            } else if (layoutType === 'LR') { // Block
                options.layout = { hierarchical: { enabled: true, direction: "LR", levelSeparation: 250, nodeSpacing: 100, sortMethod: 'hubsize' } };
            } else if (layoutType === 'Free') { // Free
                options.layout = { hierarchical: false };
                options.physics = { enabled: true, solver: 'forceAtlas2Based', stabilization: { iterations: 200 } };
            } else { // Board
                options.layout = { hierarchical: false };
                options.physics = false;
            }

            network = new vis.Network(container, data, options);
            attachEvents();

            if (layoutType === 'Free') { network.once("afterDrawing", function() { network.fit(); }); }
        }

        // --- Board Calculation ---
        function calculateBoardPositions(nodes, edges) {
            const rootId = 1;
            let columns = nodes.filter(n => n.level === 1);
            columns.sort((a,b) => (a.x || 0) - (b.x || 0));

            let processedNodes = nodes.map(n => ({...n, fixed: false}));
            let root = processedNodes.find(n => n.id === rootId);
            if(root) { root.x = 0; root.y = BOARD_CONFIG.headerY - 150; }

            const startX = -((columns.length * BOARD_CONFIG.colWidth) / 2) + (BOARD_CONFIG.colWidth/2);

            columns.forEach((col, cIdx) => {
                let colNode = processedNodes.find(n => n.id === col.id);
                if(colNode) { colNode.x = startX + (cIdx * BOARD_CONFIG.colWidth); colNode.y = BOARD_CONFIG.headerY; }

                let currentY = BOARD_CONFIG.headerY + BOARD_CONFIG.cardGap;
                function placeDescendants(parentId, depth) {
                    let children = nodes.filter(n => edges.some(e => e.from === parentId && e.to === n.id));
                    children.sort((a,b) => (a.y || 0) - (b.y || 0));
                    children.forEach(child => {
                        let childNode = processedNodes.find(n => n.id === child.id);
                        if(childNode) {
                            childNode.x = (startX + (cIdx * BOARD_CONFIG.colWidth)) + (depth * BOARD_CONFIG.indent);
                            childNode.y = currentY;
                            currentY += BOARD_CONFIG.cardGap;
                            placeDescendants(child.id, depth + 1);
                        }
                    });
                }
                placeDescendants(col.id, 0);
            });
            return processedNodes;
        }

        // --- Box Selection Logic (FIXED v6.0) ---
        function setupBoxSelection() {
            const container = document.getElementById('mynetwork');
            const box = document.getElementById('selectionBox');
            let isSelecting = false;
            let startX = 0, startY = 0;

            container.addEventListener('mousedown', function(e) {
                if (e.ctrlKey || e.metaKey) {
                    isSelecting = true;
                    // Use Page Coordinates for the Div Position
                    startX = e.pageX;
                    startY = e.pageY;
                    
                    box.style.left = startX + 'px';
                    box.style.top = startY + 'px';
                    box.style.width = '0px';
                    box.style.height = '0px';
                    box.style.display = 'block';
                    
                    network.setOptions({ interaction: { dragView: false, dragNodes: false } });
                }
            });

            window.addEventListener('mousemove', function(e) {
                if (!isSelecting) return;
                const currentX = e.pageX;
                const currentY = e.pageY;

                const width = Math.abs(currentX - startX);
                const height = Math.abs(currentY - startY);
                const newLeft = Math.min(currentX, startX);
                const newTop = Math.min(currentY, startY);

                box.style.width = width + 'px';
                box.style.height = height + 'px';
                box.style.left = newLeft + 'px';
                box.style.top = newTop + 'px';
            });

            window.addEventListener('mouseup', function(e) {
                if (!isSelecting) return;
                isSelecting = false;
                box.style.display = 'none';
                network.setOptions({ interaction: { dragView: true, dragNodes: true } });

                // Calculate selection area relative to the VIEWPORT for node detection
                // because network.canvasToDOM returns viewport-relative coordinates
                const rect = container.getBoundingClientRect();
                
                // Mouse end point in page coordinates
                const endX = e.pageX;
                const endY = e.pageY;

                // Selection box in Page Coordinates
                const selLeft = Math.min(startX, endX);
                const selRight = Math.max(startX, endX);
                const selTop = Math.min(startY, endY);
                const selBottom = Math.max(startY, endY);

                const nodeIds = nodesDS.getIds();
                const selectedNodes = [];
                
                nodeIds.forEach(id => {
                    // Get node position in Canvas
                    const canvasPos = network.getPositions([id])[id];
                    // Convert to DOM (Viewport)
                    const domPos = network.canvasToDOM(canvasPos);
                    
                    // Convert DOM (Viewport) to Page Coordinates to match selection box
                    const nodePageX = domPos.x + window.scrollX + rect.left; // Adjust for container position + scroll
                    const nodePageY = domPos.y + window.scrollY + rect.top;

                    // Simple Point-in-Rect check
                    if (nodePageX >= selLeft && nodePageX <= selRight &&
                        nodePageY >= selTop && nodePageY <= selBottom) {
                        selectedNodes.push(id);
                    }
                });

                if(selectedNodes.length > 0) {
                    network.selectNodes(selectedNodes);
                    document.getElementById('contextToolbar').style.display = 'flex';
                }
            });
        }

        // --- History / Undo / Reset ---
        function saveHistory() {
            if (!nodesDS) return;
            const s = { nodes: nodesDS.get(), edges: edgesDS.get(), layout: currentLayout };
            historyStack.push(JSON.stringify(s));
            if (historyStack.length > MAX_HISTORY) historyStack.shift();
        }

        function undo() {
            if (historyStack.length === 0) { showStatus("No more steps"); return; }
            const prevState = JSON.parse(historyStack.pop());
            initNetwork(prevState.nodes, prevState.edges, prevState.layout);
            saveSession();
            showStatus("Undo successful");
        }

        function resetMap() {
            if (!initialState) return;
            if (confirm("Reset to original state?")) {
                const s = JSON.parse(initialState);
                let initialEdges = s.edges;
                if(s.layout === 'Board' || !s.layout) {
                    initialEdges = initialEdges.map(e => ({...e, hidden: true}));
                }
                initNetwork(s.nodes, initialEdges, 'Board');
                historyStack = [];
                saveSession();
                showStatus("Reset Complete");
            }
        }

        // --- Generator ---
        function processData() {
            const text = document.getElementById('inputText').value;
            if(!text.trim()) { alert("Please input text."); return; }

            historyStack = [];
            let nodes = []; let edges = []; let nodeId = 1;
            const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
            let mainTopic = lines[0].replace(/["']/g, ""); 
            if(mainTopic.length > 50) mainTopic = mainTopic.substring(0, 50) + "...";
            
            nodes.push({id: 1, label: mainTopic, level:0, color: getNodeColor(0), shape:'box', font:{size:26, color:'#333', bold:true}});

            let lastNodeByLevel = { 0: 1 }; 
            const reLevel1 = /^(1\.|2\.|3\.|4\.|\[Îß∫ÏùåÎßê\]|ÏÑúÎ°†|Î≥∏Î°†|Í≤∞Î°†|Íµ¨ÏõêÌåå|ÌïòÎÇòÎãòÏùòÍµêÌöå|ÎèÑÏûÖ|\[)/; 
            const reLevel2 = /^(Ï≤´Ïß∏|ÎëòÏß∏|ÏÖãÏß∏|ÎÑ∑Ïß∏|ÎßàÏßÄÎßâÏúºÎ°ú|Q:|A:)/;
            const reLevel3 = /^(-|‚Ä¢|Q |A |ÏßàÎ¨∏|ÎãµÎ≥Ä)/;

            for (let i = 1; i < lines.length; i++) {
                let line = lines[i]; let labelText = line.length > 60 ? line.substring(0, 60) + "..." : line;
                let depth = 4; if (reLevel1.test(line)) depth = 1; else if (reLevel2.test(line)) depth = 2; else if (reLevel3.test(line)) depth = 3; else if (line.endsWith('?')) depth = 3; else depth = 4; 
                nodeId++; let fontSize = 18 - (depth * 2); if (fontSize < 12) fontSize = 12; 
                
                nodes.push({
                    id: nodeId, label: labelText, title: line,
                    color: { background: getNodeColor(depth).bg, border: getNodeColor(depth).border },
                    shape: 'box', font: {size: fontSize, color:'#333'}, 
                    level: depth, widthConstraint: { maximum: 260 + (depth * 10) }
                });

                let parentId = 1; 
                for (let d = depth - 1; d >= 0; d--) { if (lastNodeByLevel[d]) { parentId = lastNodeByLevel[d]; break; } }
                edges.push({from: parentId, to: nodeId});
                lastNodeByLevel[depth] = nodeId;
                for (let d = depth + 1; d <= 10; d++) delete lastNodeByLevel[d];
            }

            initialState = JSON.stringify({ nodes: nodes, edges: edges, layout: 'Board' });
            initNetwork(nodes, edges.map(e => ({...e, hidden: true})), 'Board');
            saveSession();
        }

        // --- Other Logic ---
        function attachEvents() {
            network.on("selectNode", () => { if(currentAction) return; document.getElementById('contextToolbar').style.display = 'flex'; document.getElementById('edgeToolbar').style.display = 'none'; });
            network.on("deselectNode", () => document.getElementById('contextToolbar').style.display = 'none');
            network.on("click", (params) => { if (currentAction === 'connect' && params.nodes.length > 0) { finalizeConnect(actionSourceId, params.nodes[0]); } else if (params.nodes.length === 0) { cancelAction(); } });
            network.on("doubleClick", (params) => { if(params.nodes.length > 0) editNodeText(); });

            network.on("dragEnd", function (params) {
                if (currentLayout !== 'Board' || params.nodes.length === 0) { saveSession(); return; }
                saveHistory();
                const selectedIds = params.nodes; const firstId = selectedIds[0];
                const newPos = network.getPositions([firstId])[firstId];
                const allNodes = nodesDS.get();
                let columns = allNodes.filter(n => n.level === 1);
                columns.sort((a,b) => a.x - b.x);
                let targetCol = null; let minDist = Infinity;
                const COLUMN_SNAP_DIST = 180;
                columns.forEach(col => { const dist = Math.abs(col.x - newPos.x); if(dist < minDist) { minDist = dist; targetCol = col; } });
                const rootId = 1;
                selectedIds.forEach(nodeId => {
                    if (nodeId === rootId) return;
                    const pos = network.getPositions([nodeId])[nodeId];
                    nodesDS.update({ id: nodeId, x: pos.x, y: pos.y });
                    if (pos.y < BOARD_CONFIG.headerY + 50 || minDist > COLUMN_SNAP_DIST) { updateSubtreeLevels(nodeId, 1); reParentNode(nodeId, rootId); }
                    else if (targetCol && targetCol.id !== nodeId) { updateSubtreeLevels(nodeId, 2); reParentNode(nodeId, targetCol.id); }
                });
                setTimeout(() => switchLayout('Board'), 50);
            });
        }

        function updateSubtreeLevels(rootId, newBaseLevel) {
            const node = nodesDS.get(rootId); const diff = newBaseLevel - node.level;
            function apply(nid, d) {
                let n = nodesDS.get(nid); let nextLevel = n.level + d; if (nextLevel < 1) nextLevel = 1;
                let color = getNodeColor(nextLevel);
                nodesDS.update({id: nid, level: nextLevel, color: {background: color.bg, border: color.border}});
                const children = edgesDS.get().filter(e => e.from === nid).map(e => e.to);
                children.forEach(cid => apply(cid, d));
            }
            apply(rootId, diff);
        }

        function reParentNode(childId, newParentId) {
            if (childId === 1 || childId === newParentId) return;
            const parentEdge = edgesDS.get().find(e => e.to === childId);
            if (parentEdge) { if (parentEdge.from !== newParentId) { edgesDS.remove(parentEdge.id); edgesDS.add({from: newParentId, to: childId, hidden: true}); } } 
            else { edgesDS.add({from: newParentId, to: childId, hidden: true}); }
        }

        function createNewProject() { if(confirm("Start a new project?")) { document.getElementById('inputText').value = ""; initNetwork([{id:1, label:'Main Topic', level:0, color:{background:'#FFD1DC'}}], [], 'Board'); historyStack = []; localStorage.removeItem('mindMapSessionV6_0'); showStatus("New Project Created ‚ú®"); } }
        function toggleTheme() { isDarkMode = !isDarkMode; document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light'); localStorage.setItem('theme', isDarkMode ? 'dark' : 'light'); }
        function showStatus(m) { const el = document.getElementById('statusMessage'); el.innerText = m; el.style.opacity = m ? 1 : 0; if(m) setTimeout(() => el.style.opacity = 0, 3000); }
        function saveSession() { const d = { text: document.getElementById('inputText').value, nodes: nodesDS.get(), edges: edgesDS.get(), layout: currentLayout }; localStorage.setItem('mindMapSessionV6_0', JSON.stringify(d)); }
        function restoreSession() { const s = localStorage.getItem('mindMapSessionV6_0'); if(s) { try { const d = JSON.parse(s); document.getElementById('inputText').value = d.text||""; initNetwork(d.nodes, d.edges, d.layout || 'Board'); } catch(e){} } }
        function exportProject() { const data = { nodes: nodesDS.get(), edges: edgesDS.get(), text: document.getElementById('inputText').value, layout: currentLayout }; const blob = new Blob([JSON.stringify(data)], {type: "application/json"}); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = "mindmap_project.json"; a.click(); showStatus("Project Saved! üíæ"); }
        function importProject(event) { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = function(e) { try { const data = JSON.parse(e.target.result); if(data.text) document.getElementById('inputText').value = data.text; initNetwork(data.nodes, data.edges, data.layout || 'Board'); showStatus("Project Loaded! üìÇ"); } catch(err) { alert("Error loading file."); } }; reader.readAsText(file); event.target.value = ''; }
        function copySelected() { const ids = network.getSelectedNodes(); if(ids.length > 0) clipboard = nodesDS.get(ids); showStatus(`Copied ${ids.length} nodes`); }
        function cutSelected() { copySelected(); deleteSelected(); showStatus("Cut!"); }
        function duplicateSelected() { copySelected(); pasteNodes(); }
        function pasteNodes() { if(clipboard.length === 0) return; saveHistory(); let idMap = {}; clipboard.forEach(node => { let newId = Date.now() + Math.floor(Math.random()*100000); idMap[node.id] = newId; let pos = network.getPositions([node.id])[node.id] || {x:0, y:0}; nodesDS.add({...node, id: newId, x: pos.x + 30, y: pos.y + 30, label: node.label + " (Copy)"}); }); network.selectNodes(Object.values(idMap)); saveSession(); showStatus("Pasted!"); }
        function addChildNode() { const ids = network.getSelectedNodes(); if(ids.length === 0) return; const pid = ids[0]; const l = prompt("Name:"); if(l) { const p = nodesDS.get(pid); const nid = Date.now(); nodesDS.add({id: nid, label: l, level: (p.level||0)+1, shape:'box', color: getNodeColor((p.level||0)+1)}); edgesDS.add({from: pid, to: nid, hidden: currentLayout === 'Board'}); } }
        function editNodeText() { const ids = network.getSelectedNodes(); if(ids.length === 0) return; const l = prompt("Edit:", nodesDS.get(ids[0]).label); if(l !== null) nodesDS.update({id: ids[0], label: l}); }
        function deleteSelected() { const ids = network.getSelectedNodes(); nodesDS.remove(ids); const eIds = network.getSelectedEdges(); edgesDS.remove(eIds); document.getElementById('contextToolbar').style.display = 'none'; }
        function unlinkNode() { const ids = network.getSelectedNodes(); if(ids.length === 0) return; const edges = edgesDS.get().filter(e => e.to === ids[0]); edgesDS.remove(edges.map(e => e.id)); }
        function deleteSelectedEdge() { const ids = network.getSelectedEdges(); edgesDS.remove(ids); document.getElementById('edgeToolbar').style.display = 'none'; }
        function startConnect() { const ids = network.getSelectedNodes(); if(ids.length === 0) return; actionSourceId = ids[0]; currentAction = 'connect'; showStatus("Click target node"); }
        function finalizeConnect(src, tgt) { edgesDS.add({from: src, to: tgt, hidden: currentLayout === 'Board'}); currentAction = null; showStatus("Connected"); }
        function cancelAction() { currentAction = null; showStatus(""); }
        function setupKeyboardShortcuts() { document.addEventListener('keydown', (e) => { if((e.key==='Delete'||e.key==='Backspace') && document.activeElement.tagName !== 'TEXTAREA') deleteSelected(); if((e.ctrlKey||e.metaKey) && e.key === 'c') copySelected(); if((e.ctrlKey||e.metaKey) && e.key === 'v') pasteNodes(); if((e.ctrlKey||e.metaKey) && e.key === 'z') undo(); }); }
        async function exportMap() { const el = document.getElementById('mynetwork'); const c = await html2canvas(el); const l = document.createElement('a'); l.download = 'mindmap.png'; l.href = c.toDataURL(); l.click(); }
        async function exportWord() { const el = document.getElementById('mynetwork'); const bg = el.style.backgroundColor; el.style.backgroundColor = "#fff"; const c = await html2canvas(el); const d = c.toDataURL('image/png'); el.style.backgroundColor = bg; const h = `<html><body><img src="${d}"/></body></html>`; const b = new Blob([h], { type: 'application/msword' }); const l = document.createElement('a'); l.href = URL.createObjectURL(b); l.download = 'mindmap.doc'; l.click(); }
    </script>
</body>
</html>