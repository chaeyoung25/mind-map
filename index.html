<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI ë§ˆì¸ë“œë§µ ìš”ì•½ê¸°</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        :root {
            --bg-color: #f5f5f5;
            --panel-bg: #ffffff;
            --text-color: #333333;
            --border-color: #dddddd;
            --accent-color: #007bff;
        }

        /* ë‹¤í¬ ëª¨ë“œ ë³€ìˆ˜ */
        [data-theme="dark"] {
            --bg-color: #1e1e1e;
            --panel-bg: #2d2d2d;
            --text-color: #ffffff;
            --border-color: #444444;
            --accent-color: #4dabf7;
        }

        body { font-family: 'Pretendard', 'Malgun Gothic', sans-serif; padding: 20px; background-color: var(--bg-color); color: var(--text-color); transition: 0.3s; }
        .container { display: flex; gap: 20px; height: 90vh; flex-direction: column; }
        
        @media (min-width: 768px) {
            .container { flex-direction: row; }
            .input-panel { width: 30%; }
            .map-panel { width: 70%; }
        }

        .input-panel { background: var(--panel-bg); padding: 20px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); display: flex; flex-direction: column; border: 1px solid var(--border-color); }
        .map-panel { background: var(--panel-bg); border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); position: relative; flex-grow: 1; height: 100%; border: 1px solid var(--border-color); }
        
        textarea { width: 100%; height: 200px; margin-bottom: 10px; padding: 10px; background: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 5px; resize: none; box-sizing: border-box; }
        input[type="text"] { width: 100%; padding: 10px; margin-bottom: 10px; background: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 5px; box-sizing: border-box; }
        
        .btn-group { display: flex; gap: 5px; margin-bottom: 10px; }
        button { flex: 1; padding: 10px; background-color: var(--accent-color); color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; transition: 0.2s; }
        button:hover { opacity: 0.9; }
        button.secondary { background-color: #6c757d; }
        
        #mynetwork { width: 100%; height: 100%; }
        
        .header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .toggle-switch { cursor: pointer; font-size: 20px; background: none; border: none; color: var(--text-color); }

        .controls { position: absolute; top: 10px; right: 10px; z-index: 10; display: flex; gap: 5px; }
        .controls button { padding: 5px 10px; font-size: 12px; background: rgba(0,0,0,0.5); color: white; backdrop-filter: blur(4px); }
    </style>
</head>
<body>

    <div class="container">
        <div class="input-panel">
            <div class="header-row">
                <h2>ğŸ“ ì…ë ¥ ì„¤ì •</h2>
                <button class="toggle-switch" onclick="toggleTheme()">ğŸŒ“ ëª¨ë“œ ë³€ê²½</button>
            </div>
            
            <p>í…ìŠ¤íŠ¸ ì…ë ¥:</p>
            <textarea id="inputText" placeholder="ì—¬ê¸°ì— ë‚´ìš©ì„ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”. (ì„¤êµ, ê°•ì˜, íšŒì˜ë¡ ë“±)"></textarea>
            
            <p>í•µì‹¬ í‚¤ì›Œë“œ (ë¹„ì›Œë‘ë©´ AIê°€ ìë™ ì¶”ì¶œ):</p>
            <input type="text" id="keywords" placeholder="ì˜ˆ: êµíšŒ, ì‚¬ë‘ (ë¹„ì›Œë‘ë©´ ìë™ ë¶„ì„)">
            
            <button onclick="processData()">ë§ˆì¸ë“œë§µ ìƒì„±í•˜ê¸° âœ¨</button>
            
            <hr style="width:100%; border: 0.5px solid var(--border-color); margin: 20px 0;">
            <p style="font-size:12px; opacity: 0.7;">
                * <b>ìë™ ë¶„ì„:</b> í‚¤ì›Œë“œ ì¹¸ì„ ë¹„ìš°ê³  ìƒì„±í•˜ë©´ ìì£¼ ë“±ì¥í•˜ëŠ” ë‹¨ì–´ë¥¼ ì°¾ì•„ì¤ë‹ˆë‹¤.<br>
                * <b>í¸ì§‘:</b> ë…¸ë“œë¥¼ í´ë¦­í•˜ê³  'Edit'ë¥¼ ëˆŒëŸ¬ ìˆ˜ì •í•˜ê±°ë‚˜ ì‚­ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            </p>
        </div>

        <div class="map-panel">
            <div class="controls">
                <button onclick="setLayout('UD')">íŠ¸ë¦¬í˜• (ìœ„â†“ì•„ë˜)</button>
                <button onclick="setLayout('LR')">ë¸”ë¡í˜• (ì¢Œâ†’ìš°)</button>
                <button onclick="setLayout('Free')">ë°©ì‚¬í˜• (ììœ )</button>
            </div>
            <div id="mynetwork"></div>
        </div>
    </div>

    <script>
        let network = null;
        let isDarkMode = false;

        // 1. ë‹¤í¬ ëª¨ë“œ í† ê¸€ ê¸°ëŠ¥
        function toggleTheme() {
            isDarkMode = !isDarkMode;
            document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light');
            if(network) { network.redraw(); } // ìƒ‰ìƒ ë°˜ì˜ì„ ìœ„í•´ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
        }

        // 2. ê°„ë‹¨í•œ í•œêµ­ì–´ ì¡°ì‚¬ ì œê±° ë° ë¹ˆë„ ë¶„ì„ (ìë™ í‚¤ì›Œë“œ ì¶”ì¶œìš©)
        function extractKeywords(text) {
            // ì œê±°í•  ì¡°ì‚¬ë“¤ (ë¶ˆìš©ì–´)
            const stopWords = ['ì€', 'ëŠ”', 'ì´', 'ê°€', 'ì„', 'ë¥¼', 'ì˜', 'ì—', 'ì™€', 'ê³¼', 'ë„', 'ë¡œ', 'ìœ¼ë¡œ', 'ì„œ', 'ì—ì„œ', 'í•˜ë‹¤', 'ìˆë‹¤', 'ì—†ë‹¤', 'ê²ƒ', 'ìˆ˜', 'ê·¸', 'ì´', 'ì €', 'ë“¤', 'í•œ', 'í•©ë‹ˆë‹¤', 'í–ˆìŠµë‹ˆë‹¤', 'ì…ë‹ˆë‹¤'];
            
            // ë‹¨ì–´ ìª¼ê°œê¸°
            const words = text.replace(/[.,?!""''\(\)\r\n]/g, " ").split(/\s+/);
            const wordCounts = {};

            words.forEach(word => {
                if (word.length >= 2) { // 2ê¸€ì ì´ìƒë§Œ
                    let cleanWord = word;
                    // ëì— ë¶™ì€ ì¡°ì‚¬ ì œê±° ì‹œë„
                    stopWords.forEach(sw => {
                        if (cleanWord.endsWith(sw)) {
                            cleanWord = cleanWord.slice(0, -sw.length);
                        }
                    });
                    
                    if (cleanWord.length >= 2 && !stopWords.includes(cleanWord)) {
                        wordCounts[cleanWord] = (wordCounts[cleanWord] || 0) + 1;
                    }
                }
            });

            // ë§ì´ ë‚˜ì˜¨ ìˆœì„œëŒ€ë¡œ ì •ë ¬í•´ì„œ ìƒìœ„ 5ê°œ ë½‘ê¸°
            return Object.entries(wordCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(entry => entry[0]);
        }

        // 3. ë°ì´í„° ì²˜ë¦¬ ë° ë§ˆì¸ë“œë§µ ìƒì„±
        function processData() {
            const text = document.getElementById('inputText').value;
            let keywordsRaw = document.getElementById('keywords').value;

            if(!text) { alert("í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!"); return; }

            let keywordList = [];

            // í‚¤ì›Œë“œê°€ ì—†ìœ¼ë©´ ìë™ ì¶”ì¶œ
            if (!keywordsRaw.trim()) {
                keywordList = extractKeywords(text);
                if (keywordList.length === 0) {
                    alert("ë¶„ì„í•  ë§Œí•œ í•µì‹¬ ë‹¨ì–´ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë‚´ìš©ì„ ë” ì…ë ¥í•˜ê±°ë‚˜ í‚¤ì›Œë“œë¥¼ ì§ì ‘ ì ì–´ì£¼ì„¸ìš”.");
                    return;
                }
                alert("ìë™ ì¶”ì¶œëœ í‚¤ì›Œë“œ: " + keywordList.join(", "));
            } else {
                keywordList = keywordsRaw.split(',').map(k => k.trim()).filter(k => k.length > 0);
            }

            // ë…¸ë“œì™€ ì—°ê²°ì„  ìƒì„±
            let nodes = [{id: 1, label: 'ì¤‘ì‹¬ ì£¼ì œ', color: '#FF9800', shape: 'box', font: {size: 20, color: '#fff'}}];
            let edges = [];
            let nodeId = 2;

            const sentences = text.split(/[.?!]\s+/); // ë¬¸ì¥ ë‹¨ìœ„ ë¶„ë¦¬ ê°•í™”

            keywordList.forEach(kw => {
                // í‚¤ì›Œë“œ ë…¸ë“œ (ì£¼ì œ)
                const kwId = nodeId++;
                nodes.push({id: kwId, label: kw, color: '#4CAF50', shape: 'ellipse', font: {color: '#fff'}});
                edges.push({from: 1, to: kwId});

                // í•´ë‹¹ í‚¤ì›Œë“œê°€ ë“¤ì–´ê°„ ë¬¸ì¥ ì—°ê²°
                let count = 0;
                sentences.forEach(sentence => {
                    if (sentence.includes(kw) && count < 3) { // ë„ˆë¬´ ë§ìœ¼ë©´ ë³µì¡í•˜ë‹ˆê¹Œ í‚¤ì›Œë“œë‹¹ 3ê°œë§Œ
                        const cleanSentence = sentence.trim();
                        if (cleanSentence.length > 5) { // ë„ˆë¬´ ì§§ì€ ë¬¸ì¥ ì œì™¸
                            nodes.push({id: nodeId, label: cleanSentence.substring(0, 20) + "...", title: cleanSentence, color: '#E1F5FE', shape: 'box'});
                            edges.push({from: kwId, to: nodeId});
                            nodeId++;
                            count++;
                        }
                    }
                });
            });

            drawMap(nodes, edges);
        }

        // 4. ë§ˆì¸ë“œë§µ ê·¸ë¦¬ê¸° (Vis.js)
        function drawMap(nodes, edges) {
            const container = document.getElementById('mynetwork');
            const data = {
                nodes: new vis.DataSet(nodes),
                edges: new vis.DataSet(edges)
            };
            
            const options = {
                nodes: {
                    shape: 'box',
                    margin: 10,
                    widthConstraint: { maximum: 200 }
                },
                layout: {
                    hierarchical: {
                        enabled: true,
                        direction: "UD", // ê¸°ë³¸ íŠ¸ë¦¬í˜•
                        sortMethod: "hubsize",
                        levelSeparation: 150,
                        nodeSpacing: 150
                    }
                },
                physics: false,
                manipulation: { 
                    enabled: true,
                    initiallyActive: true,
                    addNode: true,
                    addEdge: true,
                    editNode: true,
                    deleteNode: true
                }
            };

            network = new vis.Network(container, data, options);
        }

        // 5. ë ˆì´ì•„ì›ƒ ë³€ê²½ í•¨ìˆ˜
        function setLayout(type) {
            if(!network) return;

            if (type === 'UD') {
                // íŠ¸ë¦¬í˜• (ìœ„ì—ì„œ ì•„ë˜ë¡œ)
                network.setOptions({
                    layout: { hierarchical: { enabled: true, direction: "UD" } },
                    physics: false
                });
            } else if (type === 'LR') {
                // ë¸”ë¡í˜• (ì¢Œì—ì„œ ìš°ë¡œ íë¦„)
                network.setOptions({
                    layout: { hierarchical: { enabled: true, direction: "LR" } },
                    physics: false
                });
            } else {
                // ë°©ì‚¬í˜• (ììœ  ë°°ì¹˜)
                network.setOptions({
                    layout: { hierarchical: { enabled: false } },
                    physics: { 
                        enabled: true, 
                        solver: 'forceAtlas2Based',
                        stabilization: { iterations: 100 } 
                    }
                });
            }
        }
    </script>
</body>
</html>